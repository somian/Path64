/*
 * Copyright (c) 2006. PathScale Inc.  All rights reserved.
 *
   Path64 is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation version 3

   Path64 is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with Path64; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
   02110-1301, USA.

 */

/*
 * Use the definitions in math.h to generate on stdout a set of cpp "define"s
 * for the symbols associated with ISO C99 "fpclassify", suitable for inclusion
 * by Fortran (which would choke on C syntax if it simply included "math.h".)
 *
 * Also generate a symbol "FP_NANS" whose value is one greater than the biggest
 * of the "fpclassify" symbols.
 *
 * Similarly, generate cpp "define"s for the rounding-mode and exception
 * macros in fenv.h, and for the size of fenv_t.
 *
 * Finally, generate cpp "define"s for the IO EOF and EOR codes needed by
 * iso_fortran_env.F90.
 */
#include <math.h>
#include <fenv.h>
#include <stdio.h>
#include <liberrno.h>

#define MAX(a,b) (((a) > (b)) ? (a) : (b))

static void gen(char *s, int i) {
  printf("#define %s %d\n", s, i);
  }

int main(int argc, char **argv) {

  printf("/* Generated by gen_ieee_cpp_macros program - do not edit */\n");

  gen("FP_NAN", FP_NAN);
  gen("FP_INFINITE", FP_INFINITE);
  gen("FP_ZERO", FP_ZERO);
  gen("FP_SUBNORMAL", FP_SUBNORMAL);
  gen("FP_NORMAL", FP_NORMAL);

  int fp_nans = 1 +
    MAX(FP_NAN,
      MAX(FP_INFINITE,
	MAX(FP_ZERO,
	  MAX(FP_SUBNORMAL,
	    FP_NORMAL))));

  gen("FP_NANS", fp_nans);
  gen("FP_OTHER", fp_nans + 1);

  gen("FE_DOWNWARD", FE_DOWNWARD);
  gen("FE_TONEAREST", FE_TONEAREST);
  gen("FE_TOWARDZERO", FE_TOWARDZERO);
  gen("FE_UPWARD", FE_UPWARD);

  gen("FE_DIVBYZERO", FE_DIVBYZERO);
  gen("FE_INEXACT", FE_INEXACT);
  gen("FE_INVALID", FE_INVALID);
  gen("FE_OVERFLOW", FE_OVERFLOW);
  gen("FE_UNDERFLOW", FE_UNDERFLOW);
  gen("FE_ALL_EXCEPT", FE_ALL_EXCEPT);

  gen("SIZEOF_FENV_T", sizeof(fenv_t));

  gen("FERDENDR", FERDENDR);
  gen("FEEORCND", FEEORCND);

  return 0;
  }
